configfile: "config.yaml"

import os

YEARS = config["years"]

rule all:
    input:
        # year별 예측 결과
        expand(os.path.join(config["output_dir"], "predictions_{year}.gpkg"), year=YEARS),
        # 비교 결과(전역 1개)
        os.path.join(config["output_dir"], "model_comparison.csv")


# ---------------------------
# Preprocess rasters
# ---------------------------

rule preprocess_landuse:
    """
    Produce one landuse frequency raster per year.
    NOTE: scripts/preprocess_landuse.py should use snakemake.wildcards.year
          (or snakemake.params.year) to decide which year to process.
    """
    input:
        landuse_files=lambda wc: [
            os.path.join(config["data_dir"], config["landuse_dir"], f)
            for f in os.listdir(os.path.join(config["data_dir"], config["landuse_dir"]))
            if f.endswith(".tif")
        ]
    output:
        freq_raster=os.path.join(config["output_dir"], "landuse_freq_{year}.tif")
    params:
        year=lambda wc: wc.year
    script:
        "scripts/preprocess_landuse.py"


rule preprocess_mtpi:
    input:
        mtpi=os.path.join(config["data_dir"], config["files"]["mtpi"])
    output:
        mtpi_1km=os.path.join(config["output_dir"], "mtpi_1km.tif")
    script:
        "scripts/preprocess_mtpi.py"


# ---------------------------
# Prepare tables
# ---------------------------

rule prepare_monitors:
    input:
        sites=os.path.join(config["git_dir"], config["files"]["sites_history"]),
        measurements=os.path.join(config["data_dir"], config["files"]["measurements"])
    output:
        correct=os.path.join(config["output_dir"], "monitors_correct.parquet"),
        incorrect=os.path.join(config["output_dir"], "monitors_incorrect.parquet")
    script:
        "scripts/prepare_monitors.py"


rule prepare_grid:
    input:
        reference=os.path.join(config["data_dir"], config["files"]["watersheds"])
    params:
        resolution=config["grid"]["resolution"]
    output:
        grid_parquet=os.path.join(config["output_dir"], "grid_30m.parquet")
    script:
        "scripts/prepare_grid.py"


# ---------------------------
# Feature engineering
# ---------------------------

rule calc_features_monitors:
    input:
        monitors=os.path.join(config["output_dir"], "monitors_{type}.parquet"),
        dsm=os.path.join(config["data_dir"], config["files"]["dsm"]),
        dem=os.path.join(config["data_dir"], config["files"]["dem"]),
        mtpi=os.path.join(config["data_dir"], config["files"]["mtpi"]),
        mtpi_1km=os.path.join(config["output_dir"], "mtpi_1km.tif"),
        emissions=os.path.join(config["data_dir"], config["files"]["emissions"]),
        watersheds=os.path.join(config["data_dir"], config["files"]["watersheds"])
    params:
        road_dir=os.path.join(config["data_dir"], config["road_dir"]),
        # landuse_freq_{year}.tif 들이 output_dir에 생기므로, 스크립트가 필요한 year를 읽게 하려면
        # 스크립트에서 year를 별도로 받도록(예: params.year) 바꾸는 편이 가장 안전합니다.
        landuse_dir=config["output_dir"]
    output:
        features=os.path.join(config["output_dir"], "features_monitors_{type}.parquet")
    script:
        "scripts/calc_features.py"


rule calc_features_grid:
    """
    Grid features should usually be year-specific if landuse/emissions/etc. vary by year.
    """
    input:
        grid=os.path.join(config["output_dir"], "grid_30m.parquet"),
        dsm=os.path.join(config["data_dir"], config["files"]["dsm"]),
        dem=os.path.join(config["data_dir"], config["files"]["dem"]),
        mtpi=os.path.join(config["data_dir"], config["files"]["mtpi"]),
        mtpi_1km=os.path.join(config["output_dir"], "mtpi_1km.tif"),
        emissions=os.path.join(config["data_dir"], config["files"]["emissions"]),
        watersheds=os.path.join(config["data_dir"], config["files"]["watersheds"]),
        landuse_freq=os.path.join(config["output_dir"], "landuse_freq_{year}.tif")
    params:
        road_dir=os.path.join(config["data_dir"], config["road_dir"]),
        landuse_dir=config["output_dir"],
        year=lambda wc: wc.year
    output:
        features=os.path.join(config["output_dir"], "features_grid_{year}.parquet")
    script:
        "scripts/calc_features.py"


# ---------------------------
# Model training / prediction
# ---------------------------

rule tune_models:
    input:
        features=os.path.join(config["output_dir"], "features_monitors_correct.parquet")
    output:
        params=os.path.join(config["output_dir"], "best_params.json")
    script:
        "scripts/tune_models.py"


rule fit_predict:
    input:
        features_train=os.path.join(config["output_dir"], "features_monitors_correct.parquet"),
        features_grid=os.path.join(config["output_dir"], "features_grid_{year}.parquet"),
        params=os.path.join(config["output_dir"], "best_params.json")
    output:
        predictions=os.path.join(config["output_dir"], "predictions_{year}.gpkg")
    params:
        year=lambda wc: wc.year
    script:
        "scripts/fit_predict.py"


rule compare_models:
    input:
        correct=os.path.join(config["output_dir"], "features_monitors_correct.parquet"),
        incorrect=os.path.join(config["output_dir"], "features_monitors_incorrect.parquet"),
        params=os.path.join(config["output_dir"], "best_params.json")
    output:
        comparison=os.path.join(config["output_dir"], "model_comparison.csv")
    script:
        "scripts/compare_models.py"
